#!/usr/bin/env python3
"""
List BATS jobs on o.s.d & o3
"""

import argparse
import os
import re
import sys
from concurrent.futures import ThreadPoolExecutor
from datetime import datetime, timedelta

import requests

from bats.debug import debugme
from bats.repos import REPOS, find_products, grep_tarball
from bats.job import get_job, Job


VERSION = re.compile(
    "(aardvark(?:-dns)?|buildah|netavark|podman|runc|skopeo) (?:info|version)"
)
session = requests.Session()


def get_urls(repo: str) -> list[str]:
    """
    Get URL's from YAML schedules in repo
    """
    return [
        product.url
        for file in grep_tarball(repo, "*.yaml")
        for product in find_products(file)
    ]


def get_build(url: str, build: str | None) -> str | None:
    """
    Normalize build
    """
    if not build:
        return None
    # Append "-1" to aggregate tests in o.s.d
    if "openqa.suse.de" in url and build.isdigit():
        return f"{build}-1"
    return build


def get_version(title: str, info: str) -> str:
    """
    Get version
    """
    package = title.split()[0]
    if package == "aardvark":
        package = "aardvark-dns"
    version = ""
    lines = info.splitlines()
    for line in lines:
        if line.split()[0] == "Version:":
            version = line.split()[-1]
            break
    if not version:
        version = lines[0].split()[-1]
    return f"{package} {version}"


def main() -> None:
    """
    Main function
    """
    parser = argparse.ArgumentParser(
        prog="bats_jobs",
        description="list BATS jobs in o.s.d & o3",
        epilog="set GITLAB_TOKEN environment variable for gitlab",
    )
    parser.add_argument("-b", "--build", help="-DAYS_AGO or YYYYMMDD")
    parser.add_argument("-v", "--verbose", action="store_true")
    args = parser.parse_args()

    urls = []
    with ThreadPoolExecutor(max_workers=min(10, len(REPOS))) as executor:
        for results in executor.map(get_urls, REPOS):
            urls.extend(results)

    build = args.build
    if build and build.startswith("-") and len(build) < 8 and build[1:].isdigit():
        today = datetime.now().date()
        date = today - timedelta(days=int(build[1:]))
        build = date.strftime("%Y%m%d")

    with ThreadPoolExecutor(max_workers=min(10, len(urls))) as executor:
        for job in executor.map(
            lambda u: get_job(u, full=args.verbose, build=get_build(u, build)), urls
        ):
            if job is None:
                continue
            print_job(job, verbose=args.verbose)


def print_job(job: Job, verbose: bool = False) -> None:
    """
    Print job
    """
    job.result = job.result.upper() if job.result == "failed" else job.result
    print(f"{job.result:10}  {job.url:<42}  {job.name}")
    # Skip non-failed jobs
    if job.result != "FAILED":
        return
    for result in job.results:
        if verbose and not result["has_parser_text_result"]:
            for detail in result["details"]:
                if "title" not in detail:
                    continue
                if VERSION.match(detail["title"]):
                    print(
                        "\t", get_version(detail["title"], detail["text_data"]), sep=""
                    )
        # Skip non-failed modules
        if result["result"] == "failed":
            if not result["has_parser_text_result"]:
                print(f"\t{result['name']}")
                continue
            for test in result["details"]:
                # Skip non-failed sub-tests
                if test["result"] == "fail":
                    print(f"\t{result['name']:<30}  {test['text_data']}")


if __name__ == "__main__":
    if os.getenv("DEBUG"):
        session.hooks["response"].append(debugme)
    try:
        main()
    except KeyboardInterrupt:
        sys.exit(1)
    finally:
        session.close()
